**Please always maintain comments when returning code, unless the code is clearly from a copy paste!**


Hello! If you're reading this, this file is both for YOU (the LLM) to gain context from AND for you to write notes into yourself
to help future iterations of yourself to refine this codebase and maintain a central program philosophy.

You are encouraged to put important context notes here, please! As always, your help is greatly appreciated in my project and feel free to ask questions out of genuine curiosity.



I, the user talking to you, am the lead technician of an escape room. This escape room has a bar. This codebase you see IS that bar functionality.

Central tenants: 

This program is designed to be highly encapsulated with heavy emphasis on single purpose scripts/classes.

The server will be run from ONE computer, the bar itself, sitting on the counter.

The CLIENT, there will be six of, always, each on a low power computer sitting inside the escape room.

The kiosks have an existing PyQT architecture which, if you're seeing this, you likely have no context of. What matters is that the client side of the bar application will
pop up as a window overlay as a child of the main kiosk QT application.

This software will not be used by technicians or server managers but *bartenders*.

The server side should feature a TOUCHSCREEN-esque UI because bartenders will be using it on a touchscreen, even if it is a Windows app.

Data security is not really a concern with this project.


The following will be notes regarding specifics in the code. If you see anything that is no longer true, remove it:
##################################
  - A new `ServerLogic` class in `server_logic.py` has been introduced to adhere to the Single Responsibility Principle. This class now handles all backend logic, including network management, client handling, message dispatching, and data state management.
  - `app_main_window.py` has been refactored into a pure "View" component. It now delegates all business logic to the `ServerLogic` instance and updates the UI in response to signals from it.
  - Both client and server use a producer-consumer pattern for sending messages to network threads. The main thread `put`s a message onto a `queue.Queue`, and the worker thread `get`s it and sends it over the socket. This is a robust, thread-safe design.
  - Communication from worker threads back to the main UI thread is handled by Qt's signal/slot mechanism, which is also thread-safe.
  - Both `data_manager.py` and `order_manager.py` use an atomic write pattern (save to `.tmp` file, then `os.replace`). This prevents data corruption on crash.
  - Optimized the client UI refresh logic. Instead of redrawing all item tiles when a single image arrives, `app_client_window.py` now finds the specific tile and updates its pixmap directly, which is far more efficient.
  - The server now uses a dedicated `AudioManager` class (`bar_audio_manager.py`) to handle sound playback, maintaining SRP. A new `app_sounds` directory is expected at the root of the server application.
  - Order notifications on the server have been changed from a single-item flash to a global UI flash and an audible alert, triggered from `app_main_window.py`.
  - The entire client interface is inherently, intentionally sideways, as KIOSK SCREENS ARE IN LANDSCAPE, ROTATED 90 DEGREES CLOCKWISE.

**Please always maintain comments when returning code, unless the code is clearly from a copy paste!**






****PLANNED FEATURES****

Weakness: Lack of Automated Tests
Observation: There are no unit or integration tests.
Impact: As the application grows, making a change in one place (e.g., OrderManager) can have unintended consequences elsewhere. Manually testing every feature after every change is time-consuming and error-prone.
Recommendation: Introduce a testing framework like pytest.
Start with OrderManager: You can write tests that call add_order and complete_order and assert that the internal lists are correct, without ever running the UI.
Test data_manager: Write tests to ensure load_items_from_config handles missing files, corrupt JSON, etc., gracefully.
This will give you a safety net to ensure the core business logic remains correct as you add features or refactor.



Weakness: Lack of server-client heartbeat